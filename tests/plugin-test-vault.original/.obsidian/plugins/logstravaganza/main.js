/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Logstravaganza
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/console-proxy.ts
var import_obsidian2 = require("obsidian");

// src/utils.ts
var import_obsidian = require("obsidian");
function getDeviceName(app) {
  const syncPlugin = app.internalPlugins?.plugins["sync"]?.instance;
  if (!syncPlugin) {
    return "Unknown device";
  }
  return syncPlugin.deviceName ? syncPlugin.deviceName : syncPlugin.getDefaultDeviceName();
}
function prefixMsg(msg) {
  return `[Logstravaganza] ${msg}`;
}
function createQueue(onPush, debounceWrites = true) {
  const callback = debounceWrites ? (0, import_obsidian.debounce)(onPush, 1e3) : onPush;
  const queue = [];
  const handler = {
    get(target, prop) {
      if (prop === "push" || prop.description === "push") {
        callback();
      }
      return target[prop];
    }
  };
  return new Proxy(queue, handler);
}
async function getFile(vault, filename, initialContent) {
  const note = vault.getAbstractFileByPath(filename);
  return note instanceof import_obsidian.TFile ? note : await vault.create(filename, (initialContent ?? "") + "\n");
}
function getObsidianURI(vault, path) {
  const v = encodeURIComponent(vault.getName());
  const p = encodeURIComponent(path);
  return `obsidian://open?vault=${v}&file=${p}`;
}
function logLevelFilter(logEvent, logLevel) {
  switch (logLevel) {
    case "debug":
      return true;
    case "info":
      return logEvent.level !== "debug";
    case "warn":
      return !["debug", "info", "log"].includes(logEvent.level);
    case "error":
      return !["debug", "info", "log", "warn"].includes(logEvent.level);
    default:
      break;
  }
  return true;
}

// src/console-proxy.ts
var WINDOW_CONSOLE = window.console;
var ConsoleProxy = class {
  constructor(queue) {
    this.queue = queue;
  }
  // Installing the console proxy object and the listener for uncaught errors
  setup() {
    const self = this;
    const handler = {
      get(target, prop) {
        const property = target[prop];
        if (typeof property === "function") {
          return (...args) => {
            const sender = new Error().stack?.split("\n").at(2)?.replace(/^.+\((.+?)\).*$/, "$1").replace("app://obsidian.md/", "").trim();
            self.storeEvent(prop.toString(), sender, args);
            return property.apply(target, args);
          };
        }
        return property;
      }
    };
    const consoleProxy = new Proxy(window.console, handler);
    window.console = consoleProxy;
    window.addEventListener("error", this.onWindowError.bind(this));
    window.addEventListener(
      "unhandledrejection",
      this.onWindowUnhandledRejection.bind(this)
    );
    return this;
  }
  // Removing the console proxy object and the listener for uncaught errors
  teardown() {
    window.console = WINDOW_CONSOLE;
    window.removeEventListener("error", this.onWindowError.bind(this));
    window.removeEventListener(
      "unhandledrejection",
      this.onWindowUnhandledRejection.bind(this)
    );
    console.info(prefixMsg("Proxy removed"));
  }
  /**
   * Adds log events with the specified level and arguments to the log event
   * queue.
   *
   * @param level - The level of the log event.
   * @param sender - The sender of the log event (e.g., "plugin:whatever").
   * @param args - The argument(s) to be logged, optional.
   */
  storeEvent(level, sender, ...args) {
    this.queue.push({
      timestamp: /* @__PURE__ */ new Date(),
      level,
      sender,
      args: args.map(this.rewriteForLogging.bind(this))
    });
  }
  /**
   * Tries to prevent "max. call stack exceeded" errors by replacing certain
   * objects with a string representation.
   */
  rewriteForLogging(value) {
    if (value instanceof import_obsidian2.TFolder) {
      return `[TFolder] ${value.path}`;
    } else if (value instanceof import_obsidian2.TFile) {
      return `[TFile] ${value.path}`;
    } else if (value instanceof import_obsidian2.TAbstractFile) {
      return `[TAbstractFile] ${value.path}`;
    } else if (value instanceof import_obsidian2.App) {
      return "[App]";
    } else if (value instanceof import_obsidian2.Vault) {
      return "[Vault]";
    } else if (value instanceof import_obsidian2.Workspace) {
      return "[Workspace]";
    } else if (Array.isArray(value)) {
      return value.map((item) => this.rewriteForLogging(item));
    } else if (typeof value === "object" && value !== null) {
      return Object.fromEntries(
        Object.entries(value).map(([key, val]) => [key, this.rewriteForLogging(val)])
      );
    }
    return value;
  }
  /**
   * Event handler for window errors. Adds a "fatal"-level log event to the log
   * event queue.
   *
   * @param event - The error event object.
   */
  onWindowError(event) {
    const { message, colno, lineno, filename, error } = event;
    this.storeEvent(
      "fatal",
      `${filename}:${lineno}:${colno}`,
      error.name,
      message,
      error.stack || "(stack trace unavailable)"
    );
  }
  /**
   * Event handler for unhandled exceptions happening in promises. Adds a
   * "fatal"-level log event to the log event queue.
   *
   * @param event - The error event object.
   */
  onWindowUnhandledRejection(event) {
    const error = event.reason;
    if (typeof error === "string") {
      this.storeEvent(
        "fatal",
        "sender:unknown",
        "Uncaught (in promise)",
        error
      );
    } else {
      const { colno, lineno, filename } = error;
      const sender = filename && lineno && colno ? `${filename}:${lineno}:${colno}` : error.stack?.match(/at eval \((.+?)\)/)?.[1] ?? "(undetermined)";
      this.storeEvent(
        "fatal",
        sender,
        "Uncaught (in promise)",
        error.stack || "(stack trace unavailable)"
      );
    }
  }
};

// src/formatters/mdcodeblocks.ts
var mdcodeblocks_default = {
  id: "mdcodeblocks",
  title: "Markdown Code Blocks",
  description: "Generates a Markdown file containing code blocks.",
  fileExt: "md",
  format: ({ timestamp, level, sender, args }) => {
    const logMsg = args.map((arg) => {
      if (typeof arg === "string") {
        return arg;
      }
      if (Array.isArray(arg) && arg.length <= 1) {
        if (typeof arg[0] === "string") {
          return arg[0];
        }
        return JSON.stringify(arg[0], null, 2);
      }
      return JSON.stringify(arg, null, 2);
    });
    return [
      "```",
      `time: ${timestamp.toISOString()}`,
      `from: ${sender ?? ""}`,
      `level: ${level}`,
      logMsg,
      "```",
      ""
    ].join("\n");
  }
};

// src/formatters/mdtable.ts
var mdtable_default = {
  id: "mdtable",
  title: "Markdown Table",
  description: "Generates a Markdown file containing a table",
  fileExt: "md",
  contentHead: [
    "| Timestamp | Originator | Level | Message |",
    "| --------- | ---------- | ----- | ------- |"
  ].join("\n"),
  format: ({ timestamp, level, sender, args }) => {
    const logMsg = args.map((arg) => typeof arg === "string" ? arg : JSON.stringify(arg)).map(escapeForMdTable).join(" ");
    return [
      "",
      timestamp.toISOString(),
      escapeForMdTable(sender ?? ""),
      level,
      logMsg,
      ""
    ].join(" | ").trim();
  }
};
var escapeForMdTable = (str) => str.replace(/([\|\[<])/sg, "\\$1").replace(/\n/g, "<br>");

// src/formatters/ndjson.ts
var ndjson_default = {
  id: "ndjson",
  title: "NDJSON",
  description: "Generates a newline-delimited JSON file",
  fileExt: "ndjson",
  format: (logEvent) => JSON.stringify(logEvent)
};

// src/formatters.ts
var formatters = [
  mdtable_default,
  ndjson_default,
  mdcodeblocks_default
].sort((a, b) => a.title.localeCompare(b.title));
function findFormatterByID(id) {
  return formatters.find((formatter) => formatter.id === id);
}

// src/plugin-info.ts
var PLUGIN_INFO = {
  "pluginVersion": "2.2.0",
  "pluginReleasedAt": "2025-05-21T13:23:45+0200"
};

// src/settings.ts
var import_obsidian3 = require("obsidian");
var LogstravaganzaSettingTab = class extends import_obsidian3.PluginSettingTab {
  plugin;
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl, plugin } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("Output format").setDesc(`
        This plugin intercepts developer console messages, and saves them to a
        file in your vault. Select the output file format here.`).addDropdown((dropdown) => {
      dropdown.addOptions(this.allFormatters()).setValue(plugin.settings.formatterID).onChange(
        async (value) => {
          plugin.settings.formatterID = value;
          await plugin.saveSettings();
          this.display();
        }
      );
    });
    const ul = containerEl.createEl("ul", {
      cls: "setting-item-description",
      attr: { style: "margin-block-start: 0; padding-inline-start: 2em;" }
    });
    formatters.forEach((f) => {
      ul.createEl("li", { attr: { style: "margin-bottom: 0.5rem;" } }).innerHTML = `
          <strong>${f.title}</strong>: ${f.description}.<br>
          File extension: <code>.${f.fileExt}</code>
        `;
    });
    new import_obsidian3.Setting(containerEl).setName("Output folder").setDesc("Where to save the log files.").addDropdown((dropdown) => {
      dropdown.addOptions(this.allFolders()).setValue(plugin.settings.outputFolder).onChange(
        async (value) => {
          plugin.settings.outputFolder = value;
          await plugin.saveSettings();
          this.display();
        }
      );
    });
    new import_obsidian3.Setting(containerEl).setName("Include current date in filename").setDesc("Adds the YYYY-MM-DD timestamp to the output filename.").addToggle((toggle) => {
      toggle.setValue(plugin.settings.fileNameContainsDate).onChange(async (value) => {
        plugin.settings.fileNameContainsDate = value;
        await plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Log level to render").setDesc(`
        Only print out the log level equal to or above what you set here.
      `).addDropdown((dropdown) => {
      dropdown.addOption("debug", "debug (print everything)").addOption("info", "info").addOption("warn", "warn").addOption("error", "error (only print error)").setValue(plugin.settings.logLevel).onChange(async (value) => {
        plugin.settings.logLevel = value;
        await plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Debounce writing to output file").setDesc(`
        Disabling this setting will cause Logstravaganza to write everything
        to the output file as it happens, and as such will impact performance.
        Usually, you'll want to keep this setting enabled.
      `).addToggle((toggle) => {
      toggle.setValue(plugin.settings.debounceWrites).onChange(async (value) => {
        plugin.settings.debounceWrites = value;
        await plugin.saveSettings();
        this.display();
      });
    });
    const fileExt = formatters.find((f) => f.id === plugin.settings.formatterID).fileExt;
    const filename = plugin.getOutputFilename(fileExt);
    const link = getObsidianURI(this.app.vault, filename);
    containerEl.createEl("h5", { text: "Output file" });
    containerEl.createEl("p", { text: "\u2192 " }).createEl("a", { text: filename, attr: { href: link } });
    const afoURL = "https://actions.work/actions-for-obsidian?ref=plugin-logstravaganza";
    containerEl.createEl("div", {
      attr: {
        style: `
          border-radius: 0.5rem;
          border: 1px dashed var(--text-muted);
          color: var(--text-muted);
          display: grid;
          font-size: 85%;
          grid-gap: 1rem;
          grid-template-columns: auto 1fr;
          margin-top: 4rem;
          opacity: 0.75;
          padding: 1rem;
        `
      }
    }).innerHTML = `
        <a href="${afoURL}">
          <img
            src="https://actions.work/img/afo-icon.png"
            style="margin: -0.4rem -0.5rem -0.5rem 0; width: 5rem;"
            alt="Actions for Obsidian icon, a cog wheel on a glossy black background">
        </a>
        <span>
          Logstravaganza is brought to you by
          <a href="${afoURL}"><strong>Actions for Obsidian</strong></a>,
          a macOS/iOS app made by the same developer as this plugin. AFO is the
          missing link between Obsidian and macOS&nbsp;/&nbsp;iOS: 50+ Shortcuts
          actions to bring your notes and your automations together.
          <a href="${afoURL}">Take a look!</a>
        </span>
      `;
  }
  allFolders() {
    return this.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian3.TFolder).map((f) => ({
      name: `/${f.path}`.replace(/^\/+/, "/"),
      path: f.path
    })).sort((a, b) => b.name.localeCompare(a.name)).reduce(
      (obj, f) => ({ [f.path]: f.name, ...obj }),
      {}
    );
  }
  allFormatters() {
    return formatters.reduce(
      (obj, f) => ({ [f.id]: f.title, ...obj }),
      {}
    );
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  fileNameContainsDate: false,
  formatterID: "mdtable",
  outputFolder: "/",
  logLevel: "debug",
  debounceWrites: true
};
var Logstravaganza = class extends import_obsidian4.Plugin {
  queue;
  proxy;
  deviceName = getDeviceName(this.app);
  settings;
  outputFileBasename = `console-log.${this.deviceName}`;
  async onload() {
    await this.loadSettings();
    this.queue = createQueue(
      this.writeToFile.bind(this),
      this.settings.debounceWrites
    );
    this.proxy = new ConsoleProxy(this.queue).setup();
    this.proxy.storeEvent(
      "info",
      "plugin:logstravaganza",
      prefixMsg(`Proxy set up (v${PLUGIN_INFO.pluginVersion})`)
    );
    this.addSettingTab(new LogstravaganzaSettingTab(this.app, this));
    new import_obsidian4.Notice("Logstravaganza is enabled!");
  }
  onunload() {
    this.proxy.teardown();
    new import_obsidian4.Notice("Logstravaganza is disabled");
  }
  async loadSettings() {
    this.settings = { ...DEFAULT_SETTINGS, ...await this.loadData() };
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  getOutputFilename(ext) {
    const currentDate = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    const filename = this.settings.fileNameContainsDate ? `${this.outputFileBasename}.${currentDate}.${ext}` : `${this.outputFileBasename}.${ext}`;
    return (0, import_obsidian4.normalizePath)(`${this.settings.outputFolder}/${filename}`);
  }
  /**
   * This function writes the log event to the file. It is called by the queue
   * when new log events have been intercepted.
   */
  async writeToFile() {
    const { vault, workspace } = this.app;
    workspace.onLayoutReady(async () => {
      const formatter = findFormatterByID(this.settings.formatterID);
      const filename = this.getOutputFilename(formatter.fileExt);
      const file = await getFile(vault, filename, formatter.contentHead);
      let logEvent;
      while (logEvent = this.queue.shift()) {
        if (logLevelFilter(logEvent, this.settings.logLevel)) {
          let line = formatter.format(logEvent) + "\n";
          await vault.append(file, line);
        }
      }
    });
  }
};

/* nosourcemap */